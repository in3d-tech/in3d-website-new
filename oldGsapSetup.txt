import { useGLTF } from "@react-three/drei";
import { useRef, useEffect, useMemo } from "react";
import { gsap } from "gsap";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";

export function ModelComponent({ url, setScrollArea, scrollArea, astroRef }) {
  const { scene, animations } = useGLTF(url);
  const mixer = useGLTFAnimations(scene, animations);

  if (url == "/assets/models/astronaut_position (1).glb") {
    scene.traverse((child) => {
      // if (child.material) child.material.wireframe = true;
      if (child.material) {
        if (child.name == "Meteor-M2_Material_#0_0") {
          child.material.transparent = true;
          child.material.opacity = 0.5;
        }
        // child.material.transparent = true;
        // child.material.opacity = 0.8;
      }
    });
  }

  // const ref = useRef(null);

  // gsap.set(".scene", { scale: 0.7 });

  useEffect(() => {
    let timeline = gsap.timeline({
      defaults: { ease: "power1.out" },
      scrollTrigger: {
        trigger: ".section-one",
        start: "top top",
        endTrigger: "#midSection2", //".section-two",
        end: "bottom bottom",
        scrub: 1,
        markers: true,
        onEnter: () => {
          // console.log("ENTERED section 1?!");
          const areaObj = { ...scrollArea };
          areaObj.currentSection = 1;
          areaObj.prevSection = 0;
          setScrollArea(areaObj);
        },
        onEnterBack: () => {
          // console.log(" this is enter back 1??");
          // const areaObj = { ...scrollArea };
          // areaObj.currentSection = 1;
          // areaObj.prevSection = 2;
          // setScrollArea(areaObj);
        },
      },
    });
    // second section
    // let timeline2 = gsap.timeline({
    //   scrollTrigger: {
    //     trigger: ".section-three",
    //     start: "top bottom",
    //     endTrigger: ".section-four",
    //     end: "bottom bottom",
    //     onEnter: () => {
    //       console.log("entered section 2?");
    //       const areaObj = { ...scrollArea };
    //       areaObj.currentSection = 2;
    //       areaObj.prevSection = 1;
    //       setScrollArea(areaObj);
    //     },
    //     onLeaveBack: () => {
    //       console.log(" enter back 2??");

    //       const areaObj = { ...scrollArea };
    //       areaObj.currentSection = 1;
    //       areaObj.prevSection = 2;
    //       setScrollArea(areaObj);
    //     },
    //   },
    // });

    //third section

    let timeline3 = gsap.timeline({
      scrollTrigger: {
        trigger: ".section-four",
        start: "top center",
        endTrigger: ".section-two",
        end: "top bottom",
        onEnter: () => {
          // console.log("entered -3 ? ");
          const areaObj = { ...scrollArea };
          areaObj.currentSection = 3;
          areaObj.prevSection = 2;
          setScrollArea(areaObj);
        },
        onLeaveBack: () => {
          // console.log(" onLEAVE 3??");

          const areaObj = { ...scrollArea };
          areaObj.currentSection = 2;
          areaObj.prevSection = 3;
          setScrollArea(areaObj);
        },
      },
    });

    timeline
      .to(
        astroRef.current.position,
        { x: -10, y: -20.2, z: 0 },
        "simultaneously"
      )
      .to(
        astroRef.current.rotation,
        { x: 0.5, y: Math.PI + 0.3, z: -0 },
        "simultaneously"
      );
    // .from(
    //   ".helper, .tester",
    //   {
    //     y: 260,
    //     x: 200,
    //     stagger: 0.1,
    //     duration: 0.8,
    //     ease: "back",
    //   },
    //   "simultaneously"
    // );
    // above istext from earlier examplee --------<

    // .to(textRef.current, { xPercent: -20, yPercent: -30 }, "simultaneously");

    let timeline14 = gsap.timeline({
      scrollTrigger: {
        trigger: ".section-one",
        start: "top center",
        endTrigger: ".section-two",
        end: "bottom bottom",
        onEnter: () => {
          console.log("this is entered in test");
        },
        onLeaveBack: () => {
          console.log(" this is leave back test");
        },
      },
    });
  }, [astroRef]);

  return (
    <group>
      <primitive
        ref={astroRef}
        object={scene}
        dispose={null}
        // scale={[2, 2, 2]}
        scale={[3, 3, 3]}
        // position={[-10, -20.2, 0]}
        // rotation={[0.5, Math.PI + 0.3, -0]}
        position={[-9, -18.2, -7]}
        rotation={[0, Math.PI / 2 + 0.5, 0]}
      />
    </group>
  );
}

// ---------------------- MODEL 2 ----------------------------
// ---------------------- MODEL 2 ----------------------------

export function ModelComponent2({
  url,
  astroRef,
  microsoftRef,
  scrollArea,
  setScrollArea,
}) {
  const { scene, animations } = useGLTF(url);
  const mixer = useGLTFAnimations(scene, animations);

  if (url == "/assets/models/microsoft_large.glb") {
    scene.traverse((child) => {
      // if (child.isMesh) console.log("heloo world!");
      // if (child.material) child.material.wireframe = true;
    });
  }

  useEffect(() => {
    let timeline = gsap.timeline({
      defaults: { ease: "power1.out" },
      scrollTrigger: {
        trigger: ".section-three",
        start: "top bottom",
        endTrigger: ".section-three",
        end: "bottom bottom",
        scrub: 1,
        markers: true,
        onEnter: () => {
          console.log("entered section 2?");
          const areaObj = { ...scrollArea };
          areaObj.currentSection = 2;
          areaObj.prevSection = 1;
          setScrollArea(areaObj);
        },
        onLeaveBack: () => {
          console.log(" enter back 2??");

          const areaObj = { ...scrollArea };
          areaObj.currentSection = 1;
          areaObj.prevSection = 2;
          setScrollArea(areaObj);
        },
        // onEnter: () => console.log("ENTERED THE THING!"),
        // onEnterBack: () => console.log("RUNNING IT BACK AGAIN"),
      },
    });

    timeline
      .to(microsoftRef.current.position, { y: -4.5, x: 4 }, "simultaneously")
      .to(astroRef.current.position, { x: -22, y: -18 }, "simultaneously");
  }, [microsoftRef]);

  return (
    <group>
      <primitive
        ref={microsoftRef}
        object={scene}
        dispose={null}
        // scale={[2, 2, 2]}
        scale={[3, 3, 3]}
        position={[7, -9, 0]}
        rotation={[0, -0.9, 0]}
      />
    </group>
  );
}

// ---------------------- MODEL 2 end ----------------------------

// ---------------------- MODEL 3 ----------------------------
// ---------------------- MODEL 3 ----------------------------

export function ModelComponent3({ url, taasiaRef, microsoftRef }) {
  const { scene, animations } = useGLTF(url);
  const mixer = useGLTFAnimations(scene, animations);

  if (url == "/assets/models/microsoft_large.glb") {
    scene.traverse((child) => {
      // if (child.isMesh) console.log("heloo world!");
      // if (child.material) child.material.wireframe = true;
    });
  }

  useEffect(() => {
    let timeline = gsap.timeline({
      defaults: { ease: "power1.out" },
      scrollTrigger: {
        trigger: ".section-four",
        start: "top bottom",
        endTrigger: ".section-four",
        end: "bottom bottom",
        scrub: 1,
        markers: true,
        // onEnter: () => console.log("ENTERED THE THING!"),
        // onEnterBack: () => console.log("RUNNING IT BACK AGAIN"),
      },
    });

    timeline
      .to(taasiaRef.current.position, { y: -4, x: -4 }, "simultaneously")
      .to(microsoftRef.current.position, { x: 8 }, "simultaneously");
  }, [microsoftRef]);

  return (
    <group>
      <primitive
        ref={taasiaRef}
        object={scene}
        dispose={null}
        // scale={[2, 2, 2]}
        scale={[3, 3, 3]}
        position={[-8, -8, -0.2]}
        // position={[-4, -4, -0.2]}

        rotation={[0, 0.9, 0]}
      />
    </group>
  );
}
// ---------------------- MODEL 3 ----------------------------

// ANIMATE ALL

function useGLTFAnimations(scene, animations) {
  const { invalidate } = useThree();
  const mixer = useMemo(() => new THREE.AnimationMixer(scene), [scene]);

  useEffect(() => {
    if (!mixer || !animations) return;

    animations.forEach((clip) => mixer.clipAction(clip).play());

    const handler = setInterval(() => invalidate(), 1000 / 60);
    return () => clearInterval(handler);
  }, [animations, mixer, invalidate]);

  useFrame((_state, delta) => mixer && mixer.update(delta));

  return mixer;
}
